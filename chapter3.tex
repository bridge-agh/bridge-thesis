\chapter{\ChapterTitleRealizationAspects}
\label{sec:wybrane-aspekty-realizacji}

Ta sekcja pracy skupia się na najważniejszych aspektach opracowanej
aplikacji, podkreślając istotne modyfikacje przeprowadzone w~trakcie
jej implementacji. Jej celem jest szczegółowe opisanie poszczególnych
komponentów oraz zidentyfikowanie czynników, które mogły prowadzić do
ewentualnych błędów w~funkcjonowaniu systemu. Dodatkowo skoncentruje
się na prezentacji skutecznych rozwiązań dla wykrytych problemów,
oferując konkretne przykłady, które ilustrują zastosowane poprawki.

\section{Architektura serwera}

%%% TODO expand basic info
Serwer napisany w języku Scala.

\subsection{Połączenia z serwerem}

Wstępne założenia dotyczące infrastruktury aplikacji
serwerowej opierały się na wykorzystaniu języka Python
wraz z~frameworkiem FastAPI. Z~czasem jednak, w~świetle
narastających wymagań i~doświadczeń zgromadzonych
podczas etapu tworzenia, nasz zespół podjął
strategiczną decyzję o~ewolucji stosu technologicznego.
Ostatecznie, struktura serwera została skonstruowana
w~dynamicznym języku Scala, korzystając z~potencjału
frameworku Akka, specjalizującego się w~programowaniu
współbieżnym oraz rozproszonym, bazującym na
zaawansowanym modelu aktorów.

Pierwotny model komunikacji między klientem, a~serwerem
był zbudowany w~oparciu o~metodę \textbf{short polling},
%%% TODO jakiś słownik co znaczy short polling???
zaimplementowaną przy pomocy FastAPI. Ten sposób
w~praktycznym zastosowaniu ujawnił pewne ograniczenia.
Regularne zapytania wysyłane przez klienta w~celu
sprawdzenia stanu danych na serwerze prowadziły do
znacznych opóźnień w~aktualizacji interfejsu
użytkownika. Taka sytuacja stwarzała trudności nawet
przy realizacji bardzo prostych funkcji, takich jak
zmiana pozycji użytkowników w~przestrzeni lobby.

Wobec wyzwań, narzuconych przez ograniczenia wyżej wspomnianej metody, nasz
zespół rozważał migrację ku strategii \textbf{long polling}. Metoda ta,
w~odróżnieniu od konwencjonalnych technik polegających na ciągłym
wysyłaniu zapytań przez klienta w~celu odświeżenia danych, proponuje
utrzymanie otwartego kanału HTTP do czasu, aż serwer będzie miał
najnowsze informacje do przekazania. Mimo iż koncepcja ta wydawała się
obiecująca, powstały obawy związane z~koniecznością ciągłego monitorowania
potencjalnej utraty połączenia. Skłoniło nas do ostatecznej rezygnacji
z~wdrożenia tego pomysłu.

Implementacja frameworku Akka pozwoliła na ustanowienie stabilnego,
\textbf{reaktywnego} połączenia między klientem a~serwerem. Programowanie
reaktywne, koncentrujące się na płynnym przepływie danych i~ich propagacji,
umożliwiło aplikacji klienta natychmiastowo reagować na wszelkie zmiany. Jest
to szczególnie istotne w~kontekście naszej aplikacji, która charakteryzuje
się intensywną interakcją użytkownika, zwłaszcza podczas naszej kluczowej
funkcjonalności -- rozgrywki w~brydża. Zastosowanie tego podejścia
znacząco usprawniło koordynację sekwencji animacji ruchów poszczególnych
graczy.

%%% mozna opisac to pozniej
% \subsection{Testy}
% Framework Akka dostarcza także kompleksowe narzędzia do efektywnego
% testowania aktorów, w~tym symulowane środowisko czasu wykonania, które
% pozwala na dogłębne sprawdzenie zachowań asynchronicznych w~warunkach
% synchronicznych. Dzięki tym możliwościom możemy rozwijać architekturę
% serwera, mając pełne przekonanie co do jej stabilności i~niezawodności
% działania.

\section{Aplikacja webowa}
Aplikacja webowa została stworzona przy użyciu platformy Next.js oraz
języka programowania Typescript, będącego rozszerzeniem Javascriptu
o~statyczne typowanie. Ta część projektu została zrealizowana zgodnie
z~pierwotnymi założeniami. Jednakże wyjątkiem było wdrożenie funkcji
rozgrywki w~brydża. Ze względu na złożoność problemów i~wymagania
dotyczące wydajności, zdecydowano się na implementację tego elementu za
pomocą technologii wcześniej niewzględnie planowanej.

Warto zaznaczyć, że implementacja rozgrywki w~brydża została logicznie
odseparowana od reszty aplikacji, choć w~pełni integruje się z~samą
platformą i~korzysta z~wcześniej wspomnianych języków programowania.
Szczegółowy opis części znajduje się w~podrozdziale \nameref{subsec:silnik_gry}.


\subsection{Przystosowanie do backendu -- hooki}
Biblioteka React oferuje potężne narzędzie w postaci hooków, które umożliwiają efektywne zarządzanie stanem i cyklem życia komponentów. W naszym projekcie, do obsługi zapytań klienta do serwera backendowego, zdecydowaliśmy się skorzystać z hooka useSWR, pochodzącego z biblioteki SWR. Jest to wysoce efektywne rozwiązanie do pobierania danych w aplikacjach opartych na React. Aby jeszcze bardziej zoptymalizować proces, stworzyliśmy również zestaw własnych, dedykowanych hooków. Takie podejście pozwoliło na znaczną standaryzację logiki odpowiedzialnej za wysyłanie i odbieranie zapytań HTTP, co przyczyniło się do drastycznego zmniejszenia ilości kodu wymaganego do realizacji tych operacji.
\subsection{Efektywne opisywanie stylu}
W celu nadania stylów komponentom naszej aplikacji internetowej posłużyliśmy się frameworkiem Tailwind CSS w połączeniu z biblioteką Daisy UI. Zastosowanie gotowych klas dostarczonych przez te narzędzia umożliwiło nam efektywne i intuicyjne stylizowanie elementów interfejsu użytkownika, eliminując jednocześnie potrzebę bezpośredniego zarządzania plikami CSS. Dzięki temu uniknęliśmy konieczności definicji własnych klas, co często prowadzi do tworzenia zawiłego i powtarzalnego kodu. Wykorzystanie tego podejścia znacznie przyspieszyło proces rozwoju front-endu naszej aplikacji.
\subsection{Testy E2E}


\section{Silnik gry}
\label{subsec:silnik_gry}
Próba implementacji animacji, takich jak ruch kart, z wykorzystaniem wyłącznie komponentów React okazała się być nadmiernie czaso i pracochłonna. Ta część projektu została dokładniej omówiona w sekcji poświęconej Silnikowi gry.

\subsection{Integracja silnika z React'em}


\section{AI}

\subsection{TBC}
