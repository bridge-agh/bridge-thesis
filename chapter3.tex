\chapter{\ChapterTitleRealizationAspects}
\label{sec:wybrane-aspekty-realizacji}

Ta sekcja pracy skupia się na opisaniu najważniejszych aspektów
opracowanej aplikacji.
Jej celem jest szczegółowe opisanie wybranych
komponentów oraz przedstawienie czynników, które są najistotniejsze do
funkcjonowania całości systemu. Dodatkowo skoncentruje
się na prezentacji skutecznych rozwiązań dla wykrytych problemów.

\section{Architektura serwera}
%%% TODO expand basic info
Serwer napisany w języku Scala.


%%% jak działa lobby bo ciekawe

%%% utrata dostepow do endpointow w przypadku zmiany stanow lobby/gry



\subsection{Komunikacja z serwerem}
Wstępne założenia dotyczące infrastruktury aplikacji
serwerowej opierały się na wykorzystaniu języka Python
wraz z~frameworkiem FastAPI.

% TODO od tad
Z~czasem jednak, w~świetle
narastających wymagań i~doświadczeń zgromadzonych
podczas etapu tworzenia, nasz zespół podjął
strategiczną decyzję o~ewolucji stosu technologicznego.
% do tad do zmiany - "w~świetle
% narastających wymagań i~doświadczeń zgromadzonych
% podczas etapu tworzenia" totalnie wypada
Ostatecznie, struktura serwera została skonstruowana
w~dynamicznym języku Scala, korzystając z~potencjału
frameworka Akka, specjalizującego się w~programowaniu
współbieżnym oraz rozproszonym, bazującym na
zaawansowanym modelu aktorów.

Pierwotny model komunikacji między klientem a~serwerem
był zbudowany w~oparciu o~metodę \textbf{short polling},
%%% TODO jakiś słownik co znaczy short polling???
zaimplementowaną przy pomocy FastAPI. Ten sposób
w~praktycznym zastosowaniu ujawnił pewne ograniczenia.
Regularne zapytania wysyłane przez klienta w~celu
sprawdzenia stanu danych na serwerze prowadziły do
znacznych opóźnień w~aktualizacji interfejsu
użytkownika. Taka sytuacja stwarzała trudności nawet
przy realizacji bardzo prostych funkcji, takich jak
zmiana pozycji użytkowników w~przestrzeni lobby.

Wobec wyzwań, narzuconych przez ograniczenia wyżej wspomnianej metody, nasz
zespół rozważał migrację ku strategii \textbf{long polling}. Metoda ta,
w~odróżnieniu od konwencjonalnych technik polegających na ciągłym
wysyłaniu zapytań przez klienta w~celu odświeżenia danych, proponuje
utrzymanie otwartego kanału HTTP do czasu, aż serwer będzie miał
najnowsze informacje do przekazania. Mimo iż koncepcja ta wydawała się
obiecująca, powstały obawy związane z~koniecznością ciągłego monitorowania
potencjalnej utraty połączenia. Skłoniło nas do ostatecznej rezygnacji
z~wdrożenia tego pomysłu.

Implementacja frameworka Akka \cite{Akka} pozwoliła na ustanowienie stabilnego,
\textbf{reaktywnego} połączenia między klientem a~serwerem. Programowanie
reaktywne, koncentrujące się na płynnym przepływie danych i~ich propagacji,
umożliwiło aplikacji klienta natychmiastowo reagować na wszelkie zmiany. Jest
to szczególnie istotne w~kontekście naszej aplikacji, która charakteryzuje
się intensywną interakcją użytkownika, zwłaszcza podczas naszej kluczowej
funkcjonalności -- rozgrywki w~brydża. Zastosowanie tego podejścia
znacząco usprawniło koordynację sekwencji animacji ruchów poszczególnych
graczy.

%%% mozna opisac to pozniej
% \subsection{Testy}
% Framework Akka dostarcza także kompleksowe narzędzia do efektywnego
% testowania aktorów, w~tym symulowane środowisko czasu wykonania, które
% pozwala na dogłębne sprawdzenie zachowań asynchronicznych w~warunkach
% synchronicznych. Dzięki tym możliwościom możemy rozwijać architekturę
% serwera, mając pełne przekonanie co do jej stabilności i~niezawodności
% działania.

\section{Aplikacja webowa}
Aplikacja webowa została stworzona przy użyciu platformy Next.js
\cite{NextJS} oraz języka programowania Typescript \cite{Typescript},
będącego rozszerzeniem języka JavaScript o~statyczne typowanie.
Jednakże ze względu na problemy wydajnościowe rozgrywki
i~słabą responsywność interfejsu związaną z~połączeniem serwerowym
zdecydowano się na zmianę technologii odpowiedzialnych za te zadania.

Implementacja rozgrywki w~brydża została logicznie
odseparowana od reszty aplikacji, choć w~pełni integruje się z~samą
platformą i~korzysta z~wcześniej wspomnianych języków programowania.
Szczegółowy opis części znajduje się w~podrozdziale \nameref{subsec:silnik_gry}.

\subsection{Mechanizmy stanu i cyklu życia komponentów}
Biblioteka React oferuje narzędzie w~postaci \textbf{hooków},
które umożliwiają efektywne zarządzanie stanem i~cyklem życia komponentów.
Są to funkcje, które udostępniają stany obiektów, oferując do nich wgląd, automatyczną aktualizację
lub zmianę wartości stanów.

W~naszym projekcie, do obsługi zapytań klienta do serwera, zdecydowaliśmy się
skorzystać z~biblioteki SWR \cite{SWR}.
Jest to rozwiązanie, korzystające z~hooków, do
pobierania danych rozwiązujące wiele problemów implementacynych takich jak
cache'owanie i~deduplikacje (usuwanie redundantnych kopii) danych, ponawianie żądań
czy weryfikacja połączenia po odzyskaniu dostępu do sieci.

Aby jeszcze bardziej zoptymalizować proces, stworzyliśmy
również zestaw własnych, dedykowanych hooków. Takie podejście pozwoliło na
znaczną standaryzację logiki odpowiedzialnej za aktualizacje stanów przy pomocy
zapytań HTTP z~użyciem SWR. Przyczyniło się do zmniejszenia ilości
globalnych zmian kodu, gdyż zmiana implementacji nie zmieniła samego interfejsu
hooka. Funkcjonalność pozostała niezmienna i~oferowane stany miały taką samą strukturę.

%%% TODO - kod/zdjecia wybranych hook'ów (sam kod może miec dodatkowe komentarze
%%% opisujące jakies ciekawe cechy)

Jak zostało wspomniane we wcześniejszym podrozdziale, dotyczącym serwera aplikacji,
zrezygnowano ze wspomnianego rozwiązania biblioteki SWR na rzecz reaktywnego
połączenia z~serwerem. Wymusiło to zmianę implementacji wysyłania i~odbierania
zapytań do serwera. Logika
wykorzystania hooków pozostała taka sama, przez co komponenty interfejsu
zawierające wspomniane hooki nie musiały być aktualizowane po tej zmianie. \\

Poniżej przedstawione zostały hooki odpowiedzialne za aktualizacje
danych z~serwera, wykorzystując \textbf{Fetch API} do wysyłania pojedynczych
zapytań i~\textbf{WebSockety} do ustanawiania połączenia z~serwerem
i~ciągłą aktualizację oferowanego stanu przez serwer.

\begin{lstlisting}[language=JavaScript, caption=Hooki z Fetch API, label={lst:fetch-hooks}, captionpos=b]
export function useFetch<T, U>(fetcher: (request: T) => Promise<U>): FetchState<T, U> {
  const [data, setData] = useState<U | undefined>(undefined);
  const [loading, setLoading] = useState<boolean>(false);

  const trigger = useCallback((request: T) => {
    if (loading) return Promise.reject();
    setData(undefined);
    setLoading(true);
    return fetcher(request)
      .then(data => {
        setData(data);
        return data;
      })
      .finally(() => {
        setLoading(false);
      });
  }, [fetcher, loading]);

  return { trigger, data, loading };
}

async function createLobbyFetcher(unused: void): Promise<CreateLobbyResponse> {
  const token = await getIdToken();
  const res = await fetch($`$$\dollar${API_URL_SESSION_LOBBY}/create$`$, {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      "Authorization": $`$Bearer $\dollar${token}$`$
    },
  });
  if (!res.ok) return Promise.reject(res.statusText);
  return res.json();
}

export function useCreateLobby() {
  return useFetch(createLobbyFetcher);
}
\end{lstlisting}

\vspace*{0.5cm}

\begin{lstlisting}[language=JavaScript, caption=Hooki z WebSocketem, label={lst:websocket-hooks}, captionpos=b]
export function useSocket<T>(url: string | undefined): SocketState<T> {
  url = url?.replace(/^http/, "ws");

  const [data, setData] = useState<T | undefined>(undefined);
  const loading = data === undefined;

  const getAuthUrl = useCallback(() => {
    return getIdToken().then(token => {
      return $`$$\dollar${url}?access_token=$\dollar${token}$`$;
    });
  }, [url]);

  useWebSocket(url ? getAuthUrl : null, {
    shouldReconnect: () => true,
    onMessage: (event) => {
      setData(JSON.parse(event.data));
    },
    reconnectInterval: 500,
  });

  return { data, loading };
}  

export interface GetInfoResponse {
  sessionId: string
  hostId: string
  users: Player[]
  started: boolean
  gameState: GameState | null
}

export function useSessionInfo(): SocketState<GetInfoResponse> {
  return useSocket<GetInfoResponse>($`$$\dollar${API_URL_SESSION}/info$`$);
}

\end{lstlisting}

\subsection{Stylizacja interfejsu}
W~celu nadania stylów komponentom naszej aplikacji internetowej posłużono się
frameworkia Tailwind CSS. W~połączeniu z~biblioteką Daisy UI
\cite{DaisyUI}, która
w~pełni wspiera ten framework, możliwe było zastosowanie gotowych klas
stylistycznych. Oferują one nie tylko samą edycję pojedynczych elementów, ale też
utworzenie zaprojektowanych, w~pełni animowanych obiektów.

Ze względu na intuicyjne nazewnictwo klas stylizujących możliwe było szybkie
projektowanie interfejsu użytkownika i~wyeliminowało
potrzebę bezpośredniego zarządzania plikami CSS. Jest to szczególnie
przydatne, jeżeli wykorzystywany jest React, ze względu na jego naturalny podział
elementów na osobne komponenty. Wykorzystanie tego podejścia znacznie przyspieszyło
proces rozwoju części wizualnej aplikacji.


\section{Silnik gry}
\label{subsec:silnik_gry}

Silnik wizualny rozgrywki do gry w~brydża jest jednym z~kluczowych
elementów aplikacji. Podczas tworzenia go skupiono się, aby zaoferować
wydajność i~pełną integrację z~aplikacją webową.


\subsection{Framework Three.js}
Podczas próby implementacji środowiska do gry, powstał problem z~zarządzaniem
elementami kart i~ich przemieszczaniem po ekranie użytkownika. Animacje,
takie jak ruch kart, z~wykorzystaniem wyłącznie komponentów React
okazały się nadmiernie pracochłonne i~nieefektywne. Użytkownik
mobilny miał problemy z~ładowaniem kart
i~ich płynnym animowaniem. Jest to spowodowane inną architekturą procesorów
mobilnych w~porównaniu do rozwiązań desktopowych. Nie są one przystosowane
do wykonania najmocniejszych obliczeń, ale oferują niskie użycie energii. \\

Wymusiło to rezygnację z~rozwiązania wykorzystującego jedynie elementy HTML.
Dokonano zmiany na bardzo efektywny framework umożliwiający renderowanie
środowiska i~elementów 3D - Three.js
\cite{ThreeJS}.

Posiada on wszystkie potrzebne funkcje, których brakło w~naszym początkowym
podejściu. Udostępnia on:
\textit{canvas} -- którego zadaniem jest zdefiniowanie
obszaru, na którym znajdują się wyświetlane elementy;
\textit{przestrzeń 3D} - w której możemy umieszczać
karty i~przemieszczać niezależnie od struktury komponentów;
\textit{kamerę} -- pozwalającą na wykorzystanie perspektywy
w~środowisku 3D, przez co gracze mogą mieć wizualne
odczucie realnej rozgrywki gry w~brydża.

%%% TODO zdjęcie planszy gry 3D (orbithelper w gamescene)

Dodatkowo framework ten wybrany został ze względu na swoją niezwykłą wydajność.
Do renderowania elementów wykorzystuję on potencjał WebGL \cite{WebGL}.
Jest to API
w~języku JavaScript, które jest standardem webowym wykorzystywanym
w~przeglądarkach. Umożliwia on wykorzystanie akceleracji sprzętowej kart
graficznych, które są przystosowane do przetwarzania fizyki, zdjęć
i~efektów wizualnych. Kluczowe jest, że stosując wspomnianą akcelerację,
wykorzystujemy większe możliwości sprzętowe urządzeń mobilnych, jak
i~desktopowych, które nie były one w~pełni wykorzystywane przy zastosowaniu
jedynie elementów HTML.
Zastosowanie tego rozwiązania
drastycznie zwiększyło efektywność i~płynność silnika gry na tych urządzeniach.
Przykładowo badając skok wydajności, porównując pierwotny silnik z~obecnym,
na urządzeniu mobilnym, różnica jest na poziomie od około 15 wyświetlanych
klatek na sekundę aż do
ponad 140\footnote{
  Porównanie zostało wykonane na urządzeniu
  Samsung Galaxy S10+ z procesorem Samsung Exynos 9820.
}.

\subsection{Integracja silnika z Reactem}
Three.js oprócz wspomnianych zalet jest też wspierany w~postaci komponentów React.
Rozwiązania, które są wykorzystane w~aplikacji to React Three Fiber
\cite{ReactThreeFiber} i~React drei \cite{ReactDrei}. Oba oferują
wspomniane komponenty, jak i~dodatkowe moduły
wspierające prace Three.js w~środowisku React. Uniknięto w~ten sposób korzystania
z~JavaScript'a, a~wykorzystano oferowane hooki i~komponenty



\section{AI}

\section{System wdrażania do środowiska deweloperskiego}

%%% vercel jak to dziala z githubem

%%% jak stworzono backend deploy z githubem i docekrem
%%% ze github oferuje docker-repo

\section{Dodatkowe elementy aplikacji}

\subsection{Tryb mobilny}

\subsection{Motywy aplikacji}

\subsection{Grafiki wygenerowane przez AI}
