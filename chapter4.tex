\chapter{\ChapterTitleWorkOrganization}
\label{sec:organizacja-pracy}

W~tym rozdziale omówione zostały początkowe idee związane z~formą i~funkcjami
aplikacji oraz zarysem harmonogramu działań. Ponadto, przedstawiane
są narzędzia, które zespół wykorzystał do skutecznego zarządzania
i~realizacji projektu. Opisana jest również struktura organizacyjna
zespołu, jego role i~zadania w kontekście tworzenia aplikacji.

Ponadto, zawiera informacje dotyczące przygotowania narzędzi do
weryfikacji postępu pracy, z~myślą o~osobach nadzorujących proces
realizacji projektu.

\section{Charakterystyka i sposób realizacji projektu}

% TODO
% historia realizacji projektu
% co zostalo zlecone, jaki problem napotkalismy
% co zaplanowalismy, jak zaprojektowalismy
% cykl tworzenia
% milestone kluczowych funkcjonalnosci (lobby dziala, karty sa, mozna grac bez licytacji, wsyzstko dziala, dodany asystent)
% ogolne problemy i rozwiazania (bez szczegolow)
% mozna wspominac osoby za co odpowiadaly w danym czasie
% opisujemy z trzeciej osoby co robili tworzacy projekt
% i ich zadania (ogolnie bez szczegolow - wystarczy wspomniec dana konkretna czesc)
% ciekawe etapy ktore mialu duze znaczenie warto wspomniec

\section{Weryfikacja postępów w trakcie realizacji}

Sprawdzanie postępów stanowi nieodłączny element niemal każdego
projektu. Regularne ustalanie, co zostało już zrealizowane, jest kluczowe,
aby skutecznie wyznaczać nowe cele i~dostosowywać tempo prac.

\subsection{Etapy realizacji projektu}

Ważne było, żeby powstawanie kolejnych części projektu nie było blokowane przez
brak elementów potrzebnych do ich działania. Z~tego powodu projekt był realizowany
etapami. Na początku napisano logikę gry w~brydża, ponieważ ustalono, że ta część
systemu powinna być już dobrze sprawdzona i~przetestowana przed powstaniem
aplikacji umożliwiającej rozgrywkę. Kolejnym etapem była realizacja funkcjonalności
związanych z~podstawowym interfejsem użytkownika, którego największą część
stanowiło lobby i~zarządzanie nim. Następnie rozpoczęto prace nad silnikiem gry, który
umożliwił użytkownikom wykonywanie ruchów. Ostatnim kamieniem milowym była implementacja
algorytmów odpowiadających za działanie wirtualnego asystenta oraz umożliwienie
wstawienia go jako gracza do rozgrywki z~użytkownikami.

Postawienie kamieni milowych było istotne w~celu weryfikowania postępów
nad projektem. Dzięki nim możliwe ustanowienie konkretnych celów oraz~przedstawienie
ich finalizacji klientowi i~osobom nadzorującym prace.

%%% najpierw base, pozniej lobby, pozniej gra a na koncu gra z ai
%%% scisle powiazane z epicami

\subsection{Spotkania z promotorem}
Spotkania z~promotorem odbywały się przeważnie co dwa tygodnie, choć ich częstotliwość
ulegała zmianom zgodnie z~bieżącymi potrzebami i~możliwościami. Na końcowym etapie realizacji projektu zdecydowano
się na spotkania cotygodniowe, ponieważ z~uwagi na stopień zaawansowania prac konieczność odbywania
konsultacji była większa. Spotkania prowadzono stacjonarnie oraz przy użyciu platformy Microsoft Teams.

\subsection{Pracownia projektowa}
Zajęcia pracowni projektowej miały miejsce raz w~tygodniu, natomiast na szczegółowe konsultacje
poszczególne grupy umawiały się z~prowadzącym pracownię indywidualnie. Większość spotkań miała
miejsce stacjonarnie w~budynku uczelni, jednak w~przypadkach, kiedy było to utrudnione, korzystano
z~Microsoft Teams.

%%% to opisujmey w obu przypadkach \subsubsection{Microsoft Teams}


\section{Wykorzystywane narzędzia do realizacji i organizacji pracy}

Do realizacji projektu zostało wykorzystane wiele narzędzi i~technologii
dostępnych za darmo lub jako produkty open source, czyli takie,
których właściciel praw autorskich przyznaje użytkownikom prawa
do swobodnego używania, modyfikacji i~udostępniania oprogramowania.


\subsection{Planowanie i projektowanie}

Przed rozpoczęciem tworzenia pierwszego kodu aplikacji niezbędne było
opracowanie ogólnego planu i~pierwotnej wizji projektu. Zdecydowano
się na przygotowaniu strategii działania oraz
zarysu celów i~funkcji, które mają być zrealizowane w~ramach projektu.
To etap planowania stanowił fundament dla późniejszej implementacji
i~umożliwił efektywne kierowanie procesem tworzenia aplikacji.

Co więcej, w~ramach tego wstępnego etapu, zwrócono uwagę na
opracowanie wizualizacji aplikacji. Starano się osiągnąć jasny
zarys wyglądu aplikacji webowej poprzez stworzenie wstępnych projektów
interfejsu użytkownika. Ta wizualizacja odegrała kluczową rolę
w~procesie projektowania, umożliwiając zespołowi uzyskanie wyobrażenia
o~finalnym wyglądzie aplikacji i~jednocześnie dostosowywanie projektu
do oczekiwań i~potrzeb użytkowników, jak i~wzorowaniu się na utworzonej
wizualizacji.


\subsubsection{Shortcut}

Praktycznie zawsze w~trakcie tworzenia oprogramowania wymagane jest
narzędzie lub platforma udostępniająca możliwość tworzenia zadań,
zależności między nimi oraz dzielenia na większe zbiory zadań.

\begin{figure}[h!]
  \centering
  \includegraphics[width=0.9\textwidth]{img/shortcut/shortcut_backlog.png}
  \caption{Backlog z zadaniami}
\end{figure}

\begin{figure}[h!]
  \centering
  \includegraphics[width=0.9\textwidth]{img/shortcut/shortcut_epic.png}
  \caption{Epic dotyczący systemu lobby wraz z~zadaniami i~ich statusami}
\end{figure}

Zdecydowano się na narzędzie Shortcut \cite{Shortcut}, które oferuje
wszystkie potrzebne funkcjonalności. Pozwala na podział zadań na tzw.
epici -- elementy pracy zawierające wystarczająco dużo zadań do realizacji,
których nie da się ukończyć w~krótkim czasie. Dla każdego milestone'a
utworzono odpowiedni epic, dzięki czemu możliwe było prezentowanie
kolejnych części i~kluczowych etapów procesu tworzenia aplikacji.

\FloatBarrier

Również dużym plusem tego rozwiązania była integracja
z~platformą GitHub\cite{Github}, która pozwoliła na
szybkie wyszukiwanie zmian w~kodzie projektu. Poprzez
zastosowane unikalnych identyfikatorów każde zadanie
znajdujące się w~Shortcut mogło mieć odpowiednio przypisaną
zmianę, która zaszła w~projekcie.


\subsubsection{Figma}

Do utworzenia wstępnej wizualizacji aplikacji użyto narzędzie Figma \cite{Figma}.
Służy ono do projektowania graficznego, takich prac jak szkielety stron
internetowych, prototypy interfejsów użytkownika czy też otwartych przestrzeni
do zarządzania i~planowania.

\begin{figure}[h!]
  \centering
  \includegraphics[width=0.9\textwidth]{img/schematy/milestones.png}
  \caption{Szczegółowy podział milestone'ów na zadania}
\end{figure}

Warto wspomnieć, że tak jak w~\ref{fig:figma_login} lub
\ref{fig:figma_userflow} wykorzystano Figmę do stworzenia mocków i~schematów.

\FloatBarrier

\subsection{Komunikacja wewnętrzna}

W~trakcie tworzenia projektu potrzebna była szybka i~efektywna
wymiana wiadomości oraz możliwość współpracy w czasie rzeczywistym.
Wykorzystana została w~tym celu platforma Discord~\cite{Discord},
która oferuje rozmowy głosowe, kanały tekstowe i~udostępnianie
obrazu na żywo.


\subsection{System kontroli wersji}

Aby synchronizować postępy pracy i~ich historię zastosowano
system kontroli wersji Git~\cite{Git}. Wraz z~nim, do przechowywania
repozytoriów z kodem aplikacji, jak i~dokumentacji wykorzystano
platformę GitHub \cite{Github}.


\subsection{Tworzenie oprogramowania}

Rozwój oprogramowania stanowił kluczowy i~niezbędny element realizacji
założeń projektowych.
Celem było stworzenie funkcjonalnej aplikacji, która integruje
odmienne komponenty, wykorzystujące różne technologie.
W~tym celu skorzystano z~różnych narzędzi, które specjalizowały się
w~tworzeniu i~testowaniu oprogramowania, w~wymaganych przez projekt
technologiach.


\subsubsection{VSCode}

Visual Studio Code \cite{VSCode}, dalej opisywany jako VSCode,
to zaawansowany edytor kodu stworzony
przez Microsoft, który stał się jednym z~najpopularniejszych narzędzi
wśród programistów\cite{IDEIndex}.
VSCode wspiera wiele języków programowania i~znaczników od JavaScript,
TypeScript, Python, C++, Rust po HTML, CSS, JSON i~wiele innych.
Dużą zaletą VSCode jest również możliwość personalizacji. Dostępne są
tysiące rozszerzeń, które pozwalają na dostosowanie edytora do własnych
potrzeb. Użycie tego edytora znacznie usprawniło rozwój aplikacji.

Ze względu na możliwość dostosowania go do różnych języków programowania
i~technologii, stosowano go przy tworzeniu każdego elementu projektu.

Oprócz tworzenia samego oprogramowania w~tym narzędziu wykorzystano go także
do stworzenia dokumentacji aplikacji wraz z~użyciem systemu kontroli wersji Git.
Usprawniło to przebieg pracy nad dokumentem, jak i~wzajemną kontrolę
współtworzenia tekstu.


\subsubsection{Produkty Jetbrains}

Produkty JetBrains \cite{JetBrains}, w~tym dedykowane środowiska
programistyczne (IDE) dla poszczególnych języków i~ekosystemów,
takich jak Java, Python czy PHP.
Oferują one zaawansowane funkcje autouzupełniania i~głębokiej
analizy kodu. Dostarczają one również narzędzia do refaktoryzacji,
co znacząco ułatwia zarządzanie i~optymalizację projektu.

PyCharm \cite{PyCharm}, specjalizujący się w~Pythonie, był pomocny podczas tworzenia
modułu logiki gry w~brydża, a~także w~początkowej fazie konstruowania
serwera z~użyciem FastAPI.

Z~kolei IntelliJ IDEA \cite{Intellij}, ze wsparciem dla języka
Scala, znalazł zastosowanie w~procesie rozwijania ostatecznej wersji
architektury serwerowej.


\subsubsection{Postman}

Postman \cite{Postman} to narzędzie do testowania API, które umożliwia, głównie
programistom i testerom, skuteczne zarządzanie, tworzenie, udostępnianie
i~testowanie żądań HTTP. Jest to popularne środowisko do tworzenia
i~wykonywania zapytań HTTP, zwłaszcza w~kontekście testowania
endpointów RESTful API.

Postman oferuje intuicyjny interfejs graficzny, który ułatwia tworzenie,
wysyłanie i~analizowanie komunikatów sieciowych, a~także sprawdzanie
odpowiedzi serwera. Przydaje się w~wielu etapach procesu tworzenia
aplikacji, od projektowania, wczesnego testowania i~monitorowania API
w~środowisku produkcyjnym.

Przez cały proces tworzenia serwera dla aplikacji Postman był wykorzystywany
do wspomnianych wyżej celów. Było to narzędzie kluczowe w~zapewnieniu
sprawnego działania tej części systemu.


\subsection{Integracja elementów systemu}

Podział tworzonego systemu na wiele części
takich jak aplikacja webowa, serwer, wirtualny asystent
i~dokumentacja wymagał stworzenia odpowiedniego
przepływu pracy zwanego \textbf{CI/CD}. Akronim ten oznacza
ciągłą integrację/ciągłe wdrażanie. Jest on stosowany
w~celu szybkiego likwidowania błędów, przeprowadzania
testów, analizą działania i~integracją elementów systemu
aplikacji. Również pozwala on przyrostowe implementowanie
projektu i~możliwość otrzymania od klienta zwrotnych
informacji o~działaniu systemu.

Zastosowanie tego rozwiązania pozwoliło na
prezentowanie klientowi kolejnych etapów aplikacji, jak
również pozwoliło na niezależne rozwijanie
i~testowanie osobnych części systemu.

Poniżej opisano technologie i~zaprojektowane systemy,
które pozwoliły na skonstruowanie systemu CI/CD dla
tworzonego projektu.


\subsubsection{Github Actions}

Najważniejszym elementem całego systemu było zintegrowanie
repozytorium kodu
wraz z~resztą technologii. Platforma GitHub, na której
znajduje się kod tworzonej aplikacji, oferuje swoje
rozwiązanie GitHub Actions\cite{GithubActions} pozwalające
na zaawansowaną realizację CI/CD. Dla każdego elementu
projektu zostały utworzone instrukcje w~postaci plików JSON
lub wykorzystano integracje zewnętrznych narzędzi oferujące
automatyczne konfiguracje. Instrukcje te były uruchamiane
po aktualizacji kodu.


\subsubsection{Vercel}

\begin{figure}[!]
  \centering
  \includegraphics[width=0.9\textwidth]{img/github/github-vercel.png}
  \caption{Wycinek integracji platformy Vercel z~GitHub dla jednej z~gałęzi kodu aplikacji webowej}
  \label{fig:github-vercel}
\end{figure}

Platforma Vercel\cite{Vercel} była odpowiedzialna za
udostępnianie aplikacji webowej. Posiada ona wsparcie \mbox{z~GitHubem},
przez co tworzenie instrukcji odbywa się automatycznie.
Vercel, dla głównej gałęzi kodu \textit{"master"} oraz
gałęzi implementujących dodatkowe funkcje, budował aplikację
i~udostępniał na swojej platformie. W~przypadku aktualizacji
kodu, na odpowiednich gałęziach, przystępował on do ponownego
budowania aplikacji i~zastępował starą. Dla każdej gałęzi
generowany był osobny adres, więc w~przypadku zmian zawsze
najnowsza wersja aplikacji, z~danej gałęzi, była dostępna pod
tym samem odpowiadającym jej adresem. Co więcej, w przypadku
problemów lub błędów podczas budowania aplikacji, informuje
on o~tym i~udostępnienia zapisy logów, aby można było je
zweryfikować.

Na rysunku
\ref{fig:github-vercel} można zauważyć, jak dla jednej
z~gałęzi został wygenerowany adres do aplikacji
("Visit Preview") oraz że budowanie przebiegło bez problemów
(zielone zaznaczenie).

\FloatBarrier


\subsubsection{Oracle Cloud}

\begin{figure}[!]
  \centering
  \includegraphics[width=0.9\textwidth]{img/traefik/dashboard.png}
  \caption{Panel serwisów udostępnionych przez Traefik.}
  \label{fig:traefik-dashboard}
\end{figure}

Do uruchomienia serwera naszego systemu wymagane było
osobne środowisko. Wymagane było, aby oferowało ono
narzędzie do automatycznego budowania i~udostępniania
najnowszych wersji serwera, w~podobny sposób jak zostało
to rozwiązane w~przypadku aplikacji webowej.

Rozwiązano ten problem poprzez stworzenie autorskiego
narzędzia wraz z~wykorzystaniem serwera udostępnionego
przez platformę Oracle Cloud \cite{OracleCloud}.
Wykorzystując możliwość tworzenia instrukcji GitHub Actions
skonfigurowano automatyczne tworzenie obrazu kontenera
Docker \cite{Docker}, który miał za zadanie uruchamiać
serwer. Był on udostępniany w~rejestrze kontenerów na
platformie GitHub. Następnie po stronie serwera Oracle
cyklicznie był sprawdzany rejestr w~celu wykrycia
nowo powstałego obrazu kontenera. Gdy obraz posiadał
inny hash\footnote{hash -- wartość wyliczana przez tzw. "funkcję
  hashującą", która dla otrzymanych na wejściu tych
  samych danych zwraca tę samą wyliczoną wartość.}
odpowiedni skrypt uruchamiał on nową wersję kontenera.
Każda gałąź kodu, podobnie jak w~przypadku aplikacji
webowej, posiadała osobny kontener uruchomiony na serwerze
Oracle, do którego tworzony był osobny adres za pomocą
autorskich skryptów i~oprogramowania Traefik \cite{Traefik}.
Dzięki temu aplikację webową można było połączyć
z~dowolnie wybraną wersją serwera gry, na przykład, aby
przetestować nową funkcjonalność. Na rysunku
\ref{fig:traefik-dashboard} przedstawiono panel, na którym
znajduje się lista serwerów udostępnionych dla
odpowiadających im gałęzi kodu.

\FloatBarrier


\subsection{Testowanie oprogramowania}

Najważniejszym w~kontekście działania całego systemu
było zapewnienie prawidłowego funkcjonowania
serwera gry, logiki gry brydża i~asystenta.
Jest to bardzo istotne w~procesie tworzenia oprogramowania,
który opiera się na ciągłym dodawaniem kolejnych
funkcjonalności, gdyż każdy dodany element może doprowadzić
do wadliwego działania poprzez najdrobniejszy błąd.

Aby zapobiec takim zdarzeniom, zdecydowano się na utworzenie
testów, które obejmowały znaczną część kodu w~wymienionych
wyżej elementach aplikacji. Przy aktualizacji kodu,
podobnie jak we wspomnianym wcześniej systemie integracji,
testy były uruchamiane automatycznie. Podczas wystąpienia
błędu na platformie GitHub widoczna jest informacja
o~nieudanym przeprowadzeniu testów
(Rys. \ref{fig:github-commits}, \ref{fig:github-tests}).

\begin{figure}[hbt!]
  \centering
  \includegraphics[width=0.9\textwidth]{img/github/github-commits.png}
  \caption{Lista commitów z informacją o przebiegu testów dla Bridge Core}
  \label{fig:github-commits}
\end{figure}

\begin{figure}[hbt!]
  \centering
  \includegraphics[width=0.9\textwidth]{img/github/github-tests.png}
  \caption{Lista uruchomionych testów przez GitHub Actions dla Bridge Core}
  \label{fig:github-tests}
\end{figure}


\subsection{Tworzenie dokumentacji}

Do napisania dokumentacji aplikacji użyto języka \LaTeX~\cite{Latex}.
Przesyłając tekst pracy na platformę GitHub, podobnie skorzystano
\mbox{z GitHub Actions}, którą wykorzystano w celu
generacji dokumentu natychmiast po opublikowaniu zmian w~tekście pracy.
Umożliwiło to na dostęp do najnowszej wersji dokumentu dla opiekuna
pracy i~prowadzącego pracownię projektową, dzięki czemu była możliwa
ciągła weryfikacja postępów nad pracą.

